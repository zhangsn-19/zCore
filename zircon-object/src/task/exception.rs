#![allow(dead_code)]

use {
    super::*, crate::ipc::Channel, crate::object::*, alloc::sync::Arc, alloc::vec::Vec,
    core::mem::size_of, spin::Mutex,kernel_hal::UserContext
};

/// Kernel-owned exception channel endpoint.
pub struct Exceptionate {
    type_: ExceptionChannelType,
    inner: Mutex<ExceptionateInner>,
}

struct ExceptionateInner {
    channel: Option<Arc<Channel>>,
    thread_rights: Rights,
    process_rights: Rights,
}

impl Exceptionate {
    pub fn new(type_: ExceptionChannelType) -> Arc<Self> {
        Arc::new(Exceptionate {
            type_,
            inner: Mutex::new(ExceptionateInner {
                channel: None,
                thread_rights: Rights::empty(),
                process_rights: Rights::empty(),
            }),
        })
    }

    pub fn set_channel(&self, channel: Arc<Channel>) {
        let mut inner = self.inner.lock();
        inner.channel.replace(channel);
    }

    pub fn get_channel(&self) -> Option<Arc<Channel>> {
        let inner = self.inner.lock();
        inner.channel.clone()
    }
}

#[repr(C)]
pub struct ExceptionInfo {
    pub tid: KoID,
    pub pid: KoID,
    pub type_: ExceptionType,
    pub padding: u32,
}

impl ExceptionInfo {
    #[allow(unsafe_code)]
    pub fn pack(&self) -> Vec<u8> {
        let buf: [u8; size_of::<ExceptionInfo>()] = unsafe { core::mem::transmute_copy(self) };
        Vec::from(buf)
    }
}

#[repr(C)]
pub struct ExceptionHeader {
    pub size: u32,
    pub type_: ExceptionType,
}

#[cfg(target_arch = "x86_64")]
#[repr(C)]
#[derive(Default)]
pub struct ExceptionContext {
    pub vector: u64,
    pub err_code: u64,
    pub cr2: u64,
}

#[cfg(target_arch = "aarch64")]
#[repr(C)]
#[derive(Default)]
pub struct ExceptionContext {
    pub esr: u32,
    pub padding1: u32,
    pub far: u64,
    pub padding2: u64,
}

impl ExceptionContext{
    #[cfg(target_arch = "x86_64")]
    fn from_user_context(cx: &UserContext) -> Self{
        ExceptionContext{
            vector:cx.trap_num as u64,
            err_code:cx.error_code as u64,
            cr2:kernel_hal::fetch_fault_vaddr() as u64,
        }
    }
    #[cfg(target_arch = "aarch64")]
    fn from_user_context(_cx: &UserContext) -> Self{
        unimplemented!()
    }
}

#[repr(C)]
pub struct ExceptionReport {
    pub header: ExceptionHeader,
    pub context: ExceptionContext,
}

impl ExceptionReport{
    fn new(type_:ExceptionType,cx: Option<&UserContext>) -> Self{
        ExceptionReport{
            header: ExceptionHeader{
                type_,
                size:core::mem::size_of::<ExceptionReport>() as u32,
            },
            context:cx.map(ExceptionContext::from_user_context).unwrap_or_default(),
        }
    }
}

#[repr(u32)]
#[derive(Copy,Clone)]
pub enum ExceptionType {
    General = 0x008,
    FatalPageFault = 0x108,
    UndefinedInstruction = 0x208,
    SoftwareBreakpoint = 0x308,
    HardwareBreakpoint = 0x408,
    UnalignedAccess = 0x508,
    // exceptions generated by kernel instead of the hardware
    Synth = 0x8000,
    ThreadStarting = 0x8008,
    ThreadExiting = 0x8108,
    PolicyError = 0x8208,
    ProcessStarting = 0x8308,
}

#[repr(u32)]
pub enum ExceptionChannelType {
    None = 0,
    Debugger = 1,
    Thread = 2,
    Process = 3,
    Job = 4,
    JobDebugger = 5,
}

/// An Exception represents a single currently-active exception. This
/// will be transmitted to registered exception handlers in userspace and
/// provides them with exception state and control functionality.
pub struct Exception{
    base: KObjectBase,
    thread: Arc<Thread>,
    type_: ExceptionType,
    report: ExceptionReport,
    inner: Mutex<ExceptionInner>,
}

struct ExceptionInner{
    // Task rights copied from Exceptionate
    thread_rights: Rights,
    process_rights: Rights,
    resume: bool,
    second_chance: bool,
}

impl_kobject!(Exception);

impl Exception{
    pub fn create(thread: Arc<Thread>, type_: ExceptionType, cx: Option<&UserContext>) -> Arc<Self> {
        Arc::new(Exception{
            base:KObjectBase::new(),
            thread,
            type_,
            report:ExceptionReport::new(type_, cx),
            inner:Mutex::new(ExceptionInner{
                thread_rights:Rights::DEFAULT_THREAD,
                process_rights:Rights::DEFAULT_PROCESS,
                resume:false,
                second_chance:false,
            })
        })
    }
}